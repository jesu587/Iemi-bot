import os
import re
from flask import Flask, request
from twilio.twiml.messaging_response import MessagingResponse
import mysql.connector
from mysql.connector import pooling, Error
from dotenv import load_dotenv

# Cargar variables de entorno
load_dotenv()

app = Flask(__name__)

# Configuraci√≥n del pool de conexiones a la base de datos
db_pool = pooling.MySQLConnectionPool(
    pool_name="mypool",
    pool_size=5,
    host=os.getenv("DB_HOST"),
    user=os.getenv("DB_USER"),
    password=os.getenv("DB_PASSWORD"),
    database=os.getenv("DB_NAME")
)

# Diccionario para almacenar el estado de los usuarios
usuarios = {}

def obtener_conexion():
    """Obtiene una conexi√≥n del pool de MySQL"""
    try:
        return db_pool.get_connection()
    except Error as e:
        print(f"‚ùå Error en la conexi√≥n con MySQL: {e}")
        return None

def cita_disponible(fecha, hora):
    """Verifica si ya existe una cita en la misma fecha y hora"""
    conexion = obtener_conexion()
    if not conexion:
        return False

    try:
        cursor = conexion.cursor()
        cursor.execute("SELECT COUNT(*) FROM citas WHERE fecha = %s AND hora = %s", (fecha, hora))
        resultado = cursor.fetchone()
        return resultado[0] == 0  # Devuelve True si no hay citas en esa fecha y hora
    except Error as e:
        print(f"‚ùå Error al verificar disponibilidad: {e}")
        return False
    finally:
        cursor.close()
        conexion.close()

def guardar_cita(nombre, telefono, fecha, hora):
    """Guarda la cita en la base de datos"""
    conexion = obtener_conexion()
    if not conexion:
        return False

    try:
        cursor = conexion.cursor()
        sql = "INSERT INTO citas (nombre, telefono, fecha, hora) VALUES (%s, %s, %s, %s)"
        valores = (nombre, telefono, fecha, hora)
        cursor.execute(sql, valores)
        conexion.commit()
        return True
    except Error as e:
        print(f"‚ùå Error al guardar la cita: {e}")
        return False
    finally:
        cursor.close()
        conexion.close()

@app.route("/bot", methods=["POST"])
def bot():
    numero = request.form.get("From")
    mensaje = request.form.get("Body").strip().lower()
    respuesta = MessagingResponse()
    mensaje_respuesta = respuesta.message()

    # Verifica si es un usuario nuevo
    if numero not in usuarios:
        usuarios[numero] = {"estado": "inicio"}

    estado = usuarios[numero]["estado"]

    # Diccionario de estados
    estados = {
        "inicio": preguntar_nombre,
        "preguntar_nombre": preguntar_telefono,
        "preguntar_telefono": preguntar_fecha,
        "preguntar_fecha": preguntar_hora,
        "preguntar_hora": confirmar_cita
    }

    # Ejecuta la funci√≥n correspondiente al estado
    if estado in estados:
        return estados[estado](numero, mensaje, mensaje_respuesta)

    return str(respuesta)

def preguntar_nombre(numero, mensaje, mensaje_respuesta):
    """Solicita el nombre del usuario"""
    usuarios[numero]["nombre"] = mensaje
    mensaje_respuesta.body(f"Gracias, {mensaje}. ¬øCu√°l es tu n√∫mero de tel√©fono?")
    usuarios[numero]["estado"] = "preguntar_telefono"
    return str(mensaje_respuesta)

def preguntar_telefono(numero, mensaje, mensaje_respuesta):
    """Solicita el n√∫mero de tel√©fono"""
    if re.match(r"^\+?[0-9]{10,15}$", mensaje):
        usuarios[numero]["telefono"] = mensaje
        mensaje_respuesta.body("üìÖ ¬øPara qu√© fecha deseas la matr√≠cula? (Formato: YYYY-MM-DD)")
        usuarios[numero]["estado"] = "preguntar_fecha"
    else:
        mensaje_respuesta.body("‚ùå Formato de tel√©fono inv√°lido. Intenta nuevamente.")
    return str(mensaje_respuesta)

def preguntar_fecha(numero, mensaje, mensaje_respuesta):
    """Solicita la fecha de la cita"""
    if re.match(r"^\d{4}-\d{2}-\d{2}$", mensaje):
        usuarios[numero]["fecha"] = mensaje
        mensaje_respuesta.body("‚è∞ ¬øA qu√© hora? (Formato: HH:MM en formato 24 horas)")
        usuarios[numero]["estado"] = "preguntar_hora"
    else:
        mensaje_respuesta.body("‚ùå Formato de fecha inv√°lido. Usa YYYY-MM-DD.")
    return str(mensaje_respuesta)

def preguntar_hora(numero, mensaje, mensaje_respuesta):
    """Solicita la hora de la cita"""
    if re.match(r"^\d{2}:\d{2}$", mensaje):
        usuarios[numero]["hora"] = mensaje

        # Verificar si la cita est√° disponible
        if cita_disponible(usuarios[numero]["fecha"], usuarios[numero]["hora"]):
            mensaje_respuesta.body(f"üìÖ Confirmando tu cita para el {usuarios[numero]['fecha']} a las {usuarios[numero]['hora']}. ¬øEs correcto? (S√≠/No)")
            usuarios[numero]["estado"] = "confirmar_cita"
        else:
            mensaje_respuesta.body("‚ùå Lo sentimos, ya hay una cita agendada en esa fecha y hora. Elige otra.")
            usuarios[numero]["estado"] = "preguntar_fecha"
    else:
        mensaje_respuesta.body("‚ùå Formato de hora inv√°lido. Usa HH:MM en formato 24h.")
    return str(mensaje_respuesta)

def confirmar_cita(numero, mensaje, mensaje_respuesta):
    """Confirma y guarda la cita"""
    if mensaje in ["s√≠", "si"]:
        if guardar_cita(usuarios[numero]["nombre"], usuarios[numero]["telefono"], usuarios[numero]["fecha"], usuarios[numero]["hora"]):
            mensaje_respuesta.body(f"‚úÖ Cita agendada para {usuarios[numero]['fecha']} a las {usuarios[numero]['hora']}. ¬°Te esperamos!")
        else:
            mensaje_respuesta.body("‚ùå Ocurri√≥ un error al guardar la cita. Intenta de nuevo.")
    else:
        mensaje_respuesta.body("‚ùå Cita cancelada. Empecemos de nuevo. ¬øCu√°l es tu nombre?")
        usuarios[numero]["estado"] = "preguntar_nombre"
    
    del usuarios[numero]  # Reiniciar conversaci√≥n
    return str(mensaje_respuesta)

if __name__ == "__main__":
    app.run(port=5000, debug=True)


